下面我给你“拍板”：**先做 20 行级别的高收益升级点**，再给你一套**report.md 字段组织模板**（工程系统风格，不像 log），最后给你**module→package 映射与 AST 的最小落地路线**。我会尽量让你改动小、收益最大。

---

## A. “20 行就能明显提升”的点在哪里？

### 拍板 1：把 `set()` 改成“带证据的字典”——立刻变成可解释系统

你现在的 `detected_packages = set()` 最大的问题是：
**你丢掉了“为什么检测到它”的证据链**（文件、行号、触发规则）。

只要把 `set()` 换成 `dict[pkg] -> evidence[]`，你后面 report.md 的 80% 都有了。

**最小改动（核心思想）**：

* `detected_packages: dict[str, list[Evidence]]`
* 每次命中 deprecated pattern 时，不只记 `pkg`，还记：`file、line、pattern_id、reason、max_version、snippet`

你现在正则扫描已经有了 `pattern`，只缺“行号+片段”。

**怎么在 20 行内做到行号？**
不用全量逐行扫描，直接用 `re.finditer` + `count('\n')`：

```python
for rule in rules:
    for m in re.finditer(rule['pattern'], content):
        line = content.count('\n', 0, m.start()) + 1
        snippet = content[m.start(): m.start()+80].replace('\n', ' ')
        evidences[pkg].append({
            "file": str(py_path.relative_to(self.project_path)),
            "line": line,
            "pattern": rule.get("id", rule["pattern"]),
            "snippet": snippet,
            "reason": rule["reason"],
            "max_version": rule["max_version"],
        })
        detected_packages.add(pkg)
        break
```

这段改动**对外观感的提升巨大**：你立刻能输出你想要的那种句子：
“在 main.py:42 发现 FixedNoiseGP，因此锁定 botorch<=0.8.5”。

> 这就是你要的“工程系统感”的第一刀：**所有决策都有证据**。

---

### 拍板 2：版本比较别用字符串 max —— 换成 `packaging.version`

你现在 `max(results['min_python'], '3.10')` 这种字符串比较，会在某些情况下出错（例如 `'3.9' > '3.10'` 的字典序问题）。

只要 2 行：

```python
from packaging.version import Version
results['min_python'] = str(max(Version(results['min_python']), Version('3.10')))
```

这是“隐形高价值”改动：避免你未来 report 里出现离谱推荐。

---

### 拍板 3：把“推荐 Python 版本”的逻辑从“min_python”升级为“区间”

你现在是一个点：`min_python`。工程系统更像：**可行区间**。

最小实现（不超过 20 行）：

* `python_range: [min, max]`，max 默认 `'3.12'`（你自己也说不要 3.13 作为默认）
* 当检测到某些包时调整 max（例如 tensorflow 经常滞后新版本）

```python
results = {"py_min":"3.9","py_max":"3.12", ...}
if pkg in ["tensorflow"]:
    results["py_max"] = min(results["py_max"], "3.11")  # 举例
```

然后 recommendation = 在区间内选一个“最稳”的，比如 3.10。

> 这一步让你的系统从“拍脑袋”变成“约束求解雏形”。

---

## B. report.md 怎么设计，才像“工程系统”而不是 log？

### 核心原则：**分层、可追溯、可复现、可复核**

不要按时间顺序堆日志；按“决策链”组织。

我给你一个**直接可用的 report.md 结构**（你照这个字段做就行）：

---

### 1) Summary（摘要）

* Project path
* Scan mode（project/single file）
* Files scanned（py/ipynb 数量）
* Detected packages（总数）
* Final Python recommendation（推荐版本）
* Output artifacts（requirements.txt、activate_env.bat、run.bat 等）

---

### 2) Python Version Decision（Python 版本决策）

用**三段**写清楚：

**(a) Evidence sources**

* `.python-version` / `pyproject.toml` / `setup.py` / `runtime.txt` 是否命中，命中内容是什么（贴 1 行即可）

**(b) Constraints**

* `py_min`
* `py_max`
* 约束来源列表（每条带证据）

**(c) Final recommendation**

* 推荐版本
* 解释规则：如“优先 3.10（兼容性最佳）”

---

### 3) Dependency Detection（依赖检测结果）

分两类：

**(a) Direct imports**

* 从 pipreqs/AST 得到的包（列表即可）

**(b) Policy overrides（策略覆盖）**
这是你的特色：**废弃 API → 版本上限 / 联动约束**
用表格写，工程味一下子就有了：

| Package | Constraint | Trigger         | Location     | Reason                           |
| ------- | ---------- | --------------- | ------------ | -------------------------------- |
| botorch | `<=0.8.5`  | `FixedNoiseGP`  | `main.py:42` | API removed in newer versions    |
| torch   | `<2.0`     | botorch linkage | policy       | botorch 0.8.5 requires torch 1.x |

Location 里你就用你刚才做的 evidence（文件+行号）。

---

### 4) Resolution Result（解析与安装结果）

* uv resolve 是否成功
* installed count（安装包数量）
* lock 文件路径（如果有）
* 若失败：失败包 + 错误摘要（最多 10 行）

---

### 5) Reproducibility Notes（可复现说明）

重点写“复制环境”限制（你 README 已写得不错）：

* OS / arch
* disk letter/path risks
* recommended rerun on new machine

---

### 6) Appendix（附录）

把“证据链”原样列出（机器可读）

* JSON/YAML 形式附在末尾（或单独写 `report.json`）

> 工程系统感的关键就是：**人能读（md），机器能复核（json）**。

---

## C. module_to_package.json：你现在就该做，而且很容易做对

### 先用“白名单映射”，不要试图自动推断

最稳的策略：

* 只维护一份 `module_to_package.json`
* 格式：`{"cv2":"opencv-python","PIL":"Pillow", ...}`
* 扫描 import 得到的是 module 名 → 先查映射 → 再写入 requirements

最小落地规则：

1. `import cv2` → module=`cv2` → package=`opencv-python`
2. `from PIL import Image` → module=`PIL` → package=`Pillow`
3. 找不到映射时：先原样当包名（兼容多数情况）

未来再加：

* 二级模块（sklearn、matplotlib.pyplot）先截第一段
* `import foo.bar` → module=`foo`

---

## D. AST 替换正则：你现在不需要“大改”，先做“AST 兜底层”

你已经有正则扫描（用于 deprecated API），保留它是对的。
你缺的是：**常规 import 识别**更稳一些。

最小实现路线：

* 先对 `.py` 用 `ast.parse` 抽取 `Import/ImportFrom`
* `.ipynb` 继续临时转 py（你已有）
* 得到 module 列表后走 mapping + 去重

这一步不需要替换 pipreqs，先做为“第二意见”，并在 report 里写：

* `source = ast` / `source = pipreqs`
  两者取并集，冲突写出来（工程系统会这么干）。

---

## 你下一步我建议你“就做这三件事”，别贪

1. **evidence 字典 + 行号/snippet**（立刻能写 report）
2. **packaging.Version 修正版本比较**（避免坑）
3. **report.md + report.json 双输出**（系统感建立）

做完这三件，你的项目就从“能跑的脚本”跃迁到“可解释的工具”。

---

## 你要我怎么“直接落地”帮你？

你给我以下任意一个，我就可以把方案变成你能直接粘贴进项目里的成品代码（完整函数级别，不给碎片）：

* 你当前 `DEPRECATED_API_PATTERNS` 的结构样例（两条就行）
* 你 `generate_requirements` 里 pipreqs 输出处理那段（你省略了的部分）

我会按你现有风格，把：

* `Evidence` 数据结构
* `report.md` 生成
* `report.json` 生成
  一次性接到你的代码里，并保证不破坏原流程。
